module arrows

imports
  haskell

signature 
  constructors
    Nil              : List(a)
                     : a * b -> (a, b)

    ArrProcedure     : APat * ArrCommand -> Exp
    Irrefutable      : APat -> APat
    List             : List(Pat) -> APat
    Tuple            : Pat * List(Pat) -> APat
                     : Pat -> APat
    Wildcard         : APat
                     : Literal -> APat
    Labeled          : Qcon * LabeledPat -> APat
    Constr           : Gcon -> APat
    Named            : Var * APat -> APat
                     : Var -> APat
                     : APat -> LPat
    ArrOpApp         : ArrCommand * Qop * ArrCommand -> ArrCommand
    ArrForm          : Exp * List(ArrCommand) -> ArrCommand
    ArrAppBin        : ArrCommand * Exp -> ArrCommand
    ArrDo            : ArrStmtList -> ArrCommand
    ArrCase          : Exp * ArrAltList -> ArrCommand
    ArrIf            : Exp * ArrCommand * ArrCommand -> ArrCommand
    ArrLet           : Declbinds * ArrCommand -> ArrCommand
    ArrAbs           : Fargs * ArrCommand -> ArrCommand
    ArrHigher        : Exp * Exp -> ArrCommand
    ArrFirst         : Exp * Exp -> ArrCommand
    Typed            : Exp * Option(Context) * Type -> Exp
    Negation         : Exp -> Exp
    Labeled          : Exp * LabelBinds -> Exp
    Named            : Qvar * Exp -> Exp
    OpApp            : Exp * Qop * Exp -> Exp
    AppBin           : Exp * Exp -> Exp
                     : List -> Exp
    Case             : AnyExp * AltList -> Exp
    Do               : StmtList -> Exp
    If               : AnyExp * AnyExp * Exp -> Exp
    Let              : Declbinds * Exp -> Exp
    Abs              : Fargs * Exp -> Exp
    RSection         : QopNoNeg * Exp -> Exp
    LSection         : Exp * Qop -> Exp
    Product          : Exps2 -> Exp
    Lit              : Literal -> Exp
    Constr           : Gcon -> Exp
    Var              : Qvar -> Exp
    BinOpApp         : Pat * Qconop * LPat -> Pat
                     : LPat -> Pat
                     : Float-HASH -> Literal
                     : Integer-HASH -> Literal
                     : String-HASH -> Literal
                     : Char-HASH -> Literal
    CLitLit          : CLITLIT -> Literal
    PrimDouble       : PRIMDOUBLE -> Literal
    PrimFloat        : PRIMFLOAT -> Literal
    PrimString       : PRIMSTRING -> Literal
    PrimChar         : PRIMCHAR -> Literal
    PrimInt          : PRIMINTEGER -> Literal
                     : String -> Literal
    Float            : RATIONAL -> Literal
    Float            : FLOAT -> Literal
                     : Char -> Literal
    Int              : INTEGER -> Literal
                     : Qconid -> Qcon
    BinCon           : Qconsym -> Qcon
    LabeledPats      : List(FPat) -> LabeledPat
                     : Qcon -> Gcon
    ConstrApp        : Gcon * List(APat) -> LPat
    Negation         : Literal -> LPat
                     : Qconop -> Qop
                     : Qvarop -> Qop
    ArrStmtList      : ArrImplStmtList -> ArrStmtList
    ArrStmtList      : ArrExplStmtList -> ArrStmtList
    AltList          : ArrOffsideAltList -> ArrAltList
    AltList          : ArrNoOffsideAltBlock -> ArrAltList
                     : DeclList -> Declbinds
                     : List(APat) -> Fargs
                     : FlexibleContext -> Context
    Context          : List(Class) -> Context
    Context          : Class -> Context
    TFunBin          : Type * Type -> Type
    TAppBin          : Type * Type -> Type
                     : AType -> Type
    LabelBinds       : List(Fbind) -> LabelBinds
    BinOp            : Qvarsym -> Qvar
                     : Qvarid -> Qvar
    ListCompr        : Exp * List(Qual) -> List
    ListFirstFromTo  : Exp * Exp * Exp -> List
    ListFromTo       : Exp * Exp -> List
    ListFirstFrom    : Exp * Exp -> List
    ListFrom         : Exp -> List
    List             : List(Exp) -> List
                     : Exp -> AnyExp
    AltList          : OffsideAltList -> AltList
    AltList          : NoOffsideAltBlock -> AltList
    StmtList         : OffsideStmtList -> StmtList
    StmtList         : NoOffsideStmtBlock -> StmtList
                     : Qop -> QopNoNeg
    ECons            : Exp * List(Exp) -> Exps2
    PrefCon          : Qconid -> Qconop
                     : Gconsym -> Qconop
                     : QCONID -> Qconid
                     : Conid -> Qconid
                     : QCONSYM -> Qconsym
                     : Consym -> Qconsym
    PatBind          : Qvar * Pat -> FPat
    ArrStmtSeq       : ArrImplStmt * ArrImplStmtList -> ArrImplStmtList
                     : ArrImplStmt -> ArrImplStmtList
    ArrStmtSeq       : ArrStmt * ArrExplStmtList -> ArrExplStmtList
                     : ArrStmt -> ArrExplStmtList
    ArrAltSeq        : ArrOffsideAlt * ArrOffsideAltList -> ArrOffsideAltList
                     : ArrOffsideAlt -> ArrOffsideAltList
                     : ArrNoOffsideAltList -> ArrNoOffsideAltBlock
    DeclList         : OffsideDeclList_Empty0 -> DeclList
    DeclList         : NoOffsideDeclBlock -> DeclList
    FlexibleContext  : List(FlexibleClass) -> FlexibleContext
    FlexibleContext  : FlexibleClass -> FlexibleContext
    Class            : Qtycls * Tyvar * List(AType) -> Class
                     : SimpleClass -> Class
    TProd            : Types2 -> AType
    TList            : Type -> AType
                     : Type -> AType
    TVar             : Tyvar -> AType
    TCon             : Gtycon -> AType
    FBind            : Qvar * Exp -> Fbind
                     : Qvarsym1 -> Qvarsym
                     : Varsym -> Qvarsym
                     : QVARID -> Qvarid
                     : Varid -> Qvarid
    QualLet          : Declbinds -> Qual
                     : Exp -> Qual
    QualBind         : Pat * Exp -> Qual
                     : OffsideAlt -> OffsideAltList
                     : NoOffsideAltList -> NoOffsideAltBlock
                     : OffsideStmt -> OffsideStmtList
                     : NoOffsideStmtListSem -> NoOffsideStmtBlock
                     : ArrStmt -> ArrImplStmt
    ArrCmdStmt       : ArrCommand -> ArrStmt
    ArrBindStmt      : Pat * ArrCommand -> ArrStmt
    ArrLetStmt       : Declbinds -> ArrStmt
                     : ArrAlt -> ArrOffsideAlt
    ArrAltSeq        : ArrAlt * ArrNoOffsideAltList -> ArrNoOffsideAltList
                     : ArrAlt -> ArrNoOffsideAltList
    ArrAlt           : Pat * ArrCommand * MaybeWhere -> ArrAlt
                     : Empty -> OffsideDeclList_Empty0
                     : OffsideDeclList -> OffsideDeclList_Empty0
                     : NoOffsideDeclListSem_Empty0 -> NoOffsideDeclBlock
    SimpleClass      : Qtycls * Tyvar -> FlexibleClass
    Class            : Qtycls * Gtycon -> FlexibleClass
    Class            : Qtycls * Type -> FlexibleClass
                     : Qtycon -> Qtycls
                     : String -> Tyvar
    SimpleClass      : Qtycls * Tyvar -> SimpleClass
    TCons            : Type * List(Type) -> Types2
                     : Qtycon -> Gtycon
                     : QVARSYM -> Qvarsym1
                     : VARSYM -> Varsym
    QVarId           : Modid * String -> QVARID
                     : String -> Varid
                     : Where -> MaybeWhere

rules

  desugar-arrow :
    ArrProcedure(pat, cmd) -> OpApp(
                                AppBin(
                                  Var("arr")
                                , Abs(
                                    [pat]
                                  , (<tuple> pat-vars)
                                  )
                                )
                              , ">>>"
                              , (<desugar-arrow'(|pat-vars)> cmd)
                              )
    where <free-pat-vars> pat => pat-vars

  desugar-arrow'(|vars):
    ArrFirst(f, e) -> OpApp(
                        AppBin(
                          Var("arr")
                        , Abs(
                            [(<tuple-pat> vars)]
                          , e
                          )
                        )
                      , ">>>"
                      , f
                      )

  desugar-arrow'(|vars):
    ArrHigher(f, e) -> OpApp(
                         AppBin(
                           Var("arr")
                         , Abs(
                             [(<tuple-pat> vars)]
                           , Product(ECons(f, [e]))
                           )
                         )
                       , ">>>"
                       , Var("app")
                       )

  desugar-arrow'(|vars):
    ArrIf(e, c1, c2) -> OpApp(
                          AppBin(
                            Var("arr")
                          , Abs(
                              [(<tuple-pat> vars)]
                            , If(
                                e
                              , AppBin(
                                  Constr("Left")
                                , (<tuple> vars)
                                )
                              , AppBin(
                                  Constr("Right")
                                , (<tuple> vars)
                                )
                              )
                            )
                          )
                        , ">>>"
                        , OpApp(
                            (<desugar-arrow'(|vars)> c1)
                          , "|||"
                          , (<desugar-arrow'(|vars)> c2)
                          )
                        )

  desugar-arrow'(|vars):
    ArrLet(decls, c) -> OpApp(
                          AppBin(
                            Var("arr")
                          , Abs(
                              [(<tuple-pat> vars)]
                            , Let(decls, (<tuple> all-vars))
                            )
                          )
                        , ">>>"
                        , (<desugar-arrow'(|all-vars)> c)
                        )
    where <free-decls-vars> decls => decls-vars
          ; <conc> (vars, decls-vars) => all-vars

  desugar-arrow'(|vars):
    ArrAbs([p], c) -> OpApp(
                        AppBin(
                          Var("arr")
                        , Abs(
                            [ Tuple(
                                (<tuple-pat> vars)
                              , [Var(p)]
                              )
                            ]
                          , (<tuple> all-vars)
                          )
                        )
                      , ">>>"
                      , (<desugar-arrow'(|all-vars)> c)
                      )
    where <free-pat-vars> p => pat-vars
          ; <conc> (vars, pat-vars) => all-vars

  desugar-arrow'(|vars):
    ArrAppBin(c, e) -> OpApp(
                         AppBin(
                           Var("arr")
                         , Abs(
                             [(<tuple-pat> vars)]
                           , Product(
                               ECons(
                                 (<tuple> vars)
                               , [e]
                               )
                             )
                           )
                         )
                       , ">>>"
                       , (<desugar-arrow'(|vars)> c)
                       )

  desugar-arrow'(|vars):
    ArrForm(e, cs) -> <apply-all(|k)> ( e
                                      , <map(desugar-arrow'(|vars))> cs
                                      )
    where k := Abs(
                 [(<tuple-pat> vars)]
               , (<tuple> vars)
               )

  desugar-arrow'(|vars):
    ArrOpApp(c1, op, c2) -> <desugar-arrow'(|vars)> ArrForm(
                                                      BinCon(op)
                                                    , [c1, c2]
                                                    )

  desugar-arrow'(|vars):
    ArrDo(ArrStmtList(ArrCmdStmt(c))) -> <desugar-arrow'(|vars)> c

  desugar-arrow'(|vars):
    ArrDo(
      ArrStmtList(ArrStmtSeq(ArrLetStmt(decls), cs))
    ) -> OpApp(
           AppBin(
             Var("arr")
           , Abs(
               [(<tuple-pat> vars)]
             , Let(decls, (<tuple> all-vars))
             )
           )
         , ">>>"
         , ( <desugar-arrow'(|all-vars)> ArrDo(ArrStmtList(cs))
           )
         )
    where <free-decls-vars> decls => decls-vars
          ; <conc> (vars, decls-vars) => all-vars

  desugar-arrow'(|vars):
    ArrDo(
      ArrStmtList(ArrStmtSeq(ArrCmdStmt(c), cs))
    ) -> OpApp(
           AppBin(
             Var("arr")
           , Abs(
               [(<tuple-pat> vars)]
             , Product(
                 ECons(
                   (<tuple> vars)
                 , [(<tuple> vars)]
                 )
               )
             )
           )
         , ">>>"
         , OpApp(
             AppBin(
               Var("first")
             , (<desugar-arrow'(|vars)> c)
             )
           , ">>>"
           , OpApp(
               AppBin(
                 Var("arr")
               , Var("snd")
               )
             , ">>>"
             , ( <desugar-arrow'(|vars)> ArrDo(ArrStmtList(cs))
               )
             )
           )
         )

  desugar-arrow'(|vars):
    ArrDo(
      ArrStmtList(
        ArrStmtSeq(ArrBindStmt(p, c), cs)
      )
    ) -> OpApp(
           AppBin(
             Var("arr")
           , Abs(
               [(<tuple-pat> vars)]
             , Product(
                 ECons(
                   (<tuple> vars)
                 , [(<tuple> vars)]
                 )
               )
             )
           )
         , ">>>"
         , OpApp(
             AppBin(
               Var("first")
             , (<desugar-arrow'(|vars)> c)
             )
           , ">>>"
           , OpApp(
               AppBin(
                 Var("arr")
               , Abs(
                   [ Tuple(
                       p
                     , [(<tuple-pat> vars)]
                     )
                   ]
                 , (<tuple> all-vars)
                 )
               )
             , ">>>"
             , ( <desugar-arrow'(|all-vars)> ArrDo(ArrStmtList(cs))
               )
             )
           )
         )
    where <free-pat-vars> p => pat-vars
          ; <conc> (pat-vars, vars) => all-vars


rules

  tuple-pat :
    [] -> Constr(Unit())

  tuple-pat :
    [p] -> p

  tuple-pat :
    [p|ps] -> Tuple(p, ps)

  tuple :
    [] -> Constr(Unit())

  tuple :
    [e] -> e

  tuple :
    [e|es] -> Product(ECons(e, es))

  free-pat-vars =
    collect-all(?Var(_))

  free-decls-vars =
    collect-all(
      ?Var(_)
    , union
    , \ VarFunLHS(v, _) -> v \
    )

  apply-all(|k):
    (e, []) -> e

  apply-all(|k):
    (e, [c|cs]) -> <apply-all(|k)> ( AppBin(
                                       e
                                     , OpApp(
                                         AppBin(Var("arr"), k)
                                       , ">>>"
                                       , c
                                       )
                                     )
                                   , cs
                                   )

  map(s) = 
    rec x([] + [s | x]) 

  collect-all(s) =
    collect-all(s, union)

  collect-all(s,un) =
    rec x(
      ![<s> | <crush(![], un, x)>]
      <+ crush(![], un, x)
    )

  collect-all(s, un, reduce) =
    rec x(
       ![<s> | <crush(![],un,x)>]
    <+ reduce; x
    <+ crush(![],un,x)
    )

  crush(nul, sum, s) : _#(xs) -> <foldr(nul, sum, s)> xs

  foldr(s1, s2, f)  = []; s1 + \ [y|ys] -> <s2> (<f> y, <foldr(s1, s2, f)> ys) \

  conc =
    \ (l1, l2) -> <at-end(!l2)> l1 \
    <+ \ "" # (xs) -> <concat> xs \

  at-end(s) = 
    rec x([id | x] + []; s)

  concat =
    rec x([] + \ [l | ls] -> <at-end(<x> ls)> l\ )

  union : (l1, l2) -> <rec x(
       ([]; !l2)
       <+ (HdMember(!l2); x)
       <+ [id | x]
    )> l1

  HdMember(mklst) : 
     [x | xs] -> xs 
     where mklst; fetch(\y -> <eq> (x, y)\)

  fetch(s) = 
    rec x([s | id] <+ [id | x])

  eq = ?(x, x)

  oncetd(s) = rec x(s <+ one(x))

strategies
  main = oncetd(desugar-arrow)
