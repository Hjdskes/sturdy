module cca

signature
  constructors
    Nil              : List(a)
    Cons             : a * List(a) -> List(a)

    AppBin           : Exp * Exp -> Exp
    OpApp            : Exp * Qop * Exp -> Exp
    Product          : Exps2 -> Exp
    ECons            : Exp * List(Exp) -> Exps2
    Typed            : Exp * Option(Context) * Type -> Exp
    Negation         : Exp -> Exp
    Labeled          : Exp * LabelBinds -> Exp
    Named            : Qvar * Exp -> Exp
    OpApp            : Exp * Qop * Exp -> Exp
    Case             : AnyExp * AltList -> Exp
    Do               : StmtList -> Exp
    If               : AnyExp * AnyExp * Exp -> Exp
    Let              : Declbinds * Exp -> Exp
    Abs              : Fargs * Exp -> Exp
    RSection         : QopNoNeg * Exp -> Exp
    LSection         : Exp * Qop -> Exp
    Lit              : Literal -> Exp
    Constr           : Gcon -> Exp
    Var              : Qvar -> Exp
    ArrProcedure     : APat * ArrCommand -> Exp
    BinOp            : Qvarsym -> Qvar
                     : Qvarid -> Qvar
		     : QVARID -> Qvarid
		     : Varid -> Qvarid
		     : Qconop -> Qop
		     : Qvarop -> Qop
		     : FlexibleContext -> Context
    Context          : List(Class) -> Context
    Context          : Class -> Context
    TFunBin          : Type * Type -> Type
    TAppBin          : Type * Type -> Type
                     : AType -> Type
    TProd            : Types2 -> AType
    TList            : Type -> AType
                     : Type -> AType
    TVar             : Tyvar -> AType
    TCon             : Gtycon -> AType
    TCons            : Type * List(Type) -> Types2
    LabelBinds       : List(Fbind) -> LabelBinds
                     : Exp -> AnyExp
		     : DeclList -> Declbinds
		     : List(APat) -> Fargs
		     : Qop -> QopNoNeg
                     : Float-HASH -> Literal
                     : Integer-HASH -> Literal
                     : String-HASH -> Literal
                     : Char-HASH -> Literal
    CLitLit          : CLITLIT -> Literal
    PrimDouble       : PRIMDOUBLE -> Literal
    PrimFloat        : PRIMFLOAT -> Literal
    PrimString       : PRIMSTRING -> Literal
    PrimChar         : PRIMCHAR -> Literal
    PrimInt          : PRIMINTEGER -> Literal
                     : String -> Literal
    Float            : RATIONAL -> Literal
    Float            : FLOAT -> Literal
                     : Char -> Literal
    Int              : INTEGER -> Literal
                     : Qcon -> Gcon
    EmptyList        : Gcon
    Unit             : Gcon
    Irrefutable      : APat -> APat
    List             : List(Pat) -> APat
    Tuple            : Pat * List(Pat) -> APat
                     : Pat -> APat
    Wildcard         : APat
                     : Literal -> APat
    Labeled          : Qcon * LabeledPat -> APat
    Constr           : Gcon -> APat
    Named            : Var * APat -> APat
                     : Var -> APat

rules

  step :
    OpApp(
      AppBin(Var("arr"), f)
    , ">>>"
    , AppBin(Var("arr"), g)
    ) -> AppBin(
           Var("arr")
         , OpApp(g, ".", f)
         )

  step :
    OpApp(
      AppBin(Var("arr"), f)
    , ">>>"
    , AppBin(
        AppBin(Var("loopD"), i)
      , g
      )
    ) -> AppBin(
           AppBin(Var("loopD"), i)
         , OpApp(
             g
           , "."
           , OpApp(f, "***", Var("id"))
           )
         )

  step :
    OpApp(
      AppBin(
        AppBin(Var("loopD"), i)
      , f
      )
    , ">>>"
    , AppBin(Var("arr"), g)
    ) -> AppBin(
           AppBin(Var("loopD"), i)
         , OpApp(
             OpApp(g, "***", Var("id"))
           , "."
           , f
           )
         )

  step :
    OpApp(
      AppBin(
        AppBin(Var("loopD"), i)
      , f
      )
    , ">>>"
    , AppBin(
        AppBin(Var("loopD"), j)
      , g
      )
    ) -> AppBin(
           AppBin(
             Var("loopD")
           , Product(ECons(i, [j]))
           )
         , AppBin(
             Var("assoc'")
           , OpApp(
               AppBin(
                 Var("juggle'")
               , OpApp(g, "***", Var("id"))
               )
             , "."
             , OpApp(f, "***", Var("id"))
             )
           )
         )

  step :
    AppBin(
      Var("first")
    , AppBin(
        AppBin(Var("loopD"), i)
      , f
      )
    ) -> AppBin(
           AppBin(Var("loopD"), i)
         , AppBin(
             Var("juggle'")
           , OpApp(
               Var("f")
             , "***"
             , Var("id")
             )
           )
         )

  step :
    AppBin(
      Var("loop")
    , AppBin(Var("arr"), f)
    ) -> AppBin(
           Var("arr")
         , AppBin(Var("trace"), f)
         )

  step :
    AppBin(
      Var("loop")
    , AppBin(
        AppBin(Var("loopD"), i)
      , f
      )
    ) -> AppBin(
           AppBin(Var("loopD"), i)
         , AppBin(
             Var("trace")
           , AppBin(
               Var("juggle'")
             , Var("f")
             )
           )
         )

  norm :
    AppBin(Var("arr"), f) -> AppBin(Var("arr"), f)

  norm :
    AppBin(
      AppBin(Var("loopD"), i)
    , f
    ) -> AppBin(
           AppBin(Var("loopD"), i)
         , f
         )

  norm :
    AppBin(Var("init"), i) -> AppBin(
                                AppBin(Var("loopD"), i)
                              , Var("swap")
                              )

  norm :
    OpApp(e1, ">>>", e2) -> <step> OpApp(n1, ">>>", n2)
    where <norm> e1 => n1
          ; <norm> e2 => n2

  norm :
    AppBin(Var("first"), f) -> <step> AppBin(Var("first"), nf)
    where <norm> f => nf

  norm :
    AppBin(Var("loop"), f) -> <step> AppBin(Var("loop"), nf)
    where <norm> f => nf
